#THE PRIMARY INTENTION IS TO MAKE THE CHAIN DYNAMIC SUCH THAT WHEN TWO ROBOTS ARE CONNECTED IN THE RIGHT
#SEQUENCE THEY TURN GREEN


# POSSIBLE SCENARIOS INCLUDES
#1. SEPERATELY FORMING THE TWO CLUSTERS WITH SAY ONLY TWO MEMBERS .EACH CLUSTER MUST HAVE ID VALUES IN 1-2 AND 1-2 NUMBER SEQUENCE

#2. BRINGING THESE CLUSTERS TOGETHER THEY RE-ASSGIN THE IDs ALL OVER AGAIN


# QUESTIONS : HOW TO GENERATE ID RANDOMLY
# AND IF ANY OF THE ROBOT HAVE RANDOM VALUE GREATER THAN THE OTHER IT SET ITS OWN ID AND TELLS THE OTHER ROBOT TO ASSIGN ITS ID TO BE +1

# GENERATE RANDON ID ON TWO CONDITIONS
# 1. ROBOT CURRENTLY HAS NO CONNECTED NEIGHNBOURS
# 2. A RESET HAS BEING INITIATED POSSIBLY WHEN TWO DIFFERENT CLUSTERS ARE MERGED
# 3.

# VARIABLES
var MY_ID = 0
var TEMP_MY_ID = 0
var BROADCAST_ID = 1020
var ACK_RCVD = 0
var PREV_BROADCAST= 0 #THIS REQUIRED JUST TO KEEP TRACK OF PREVIOUS BROADCAST SO THAT THE BROADCAST DOESNT CLASH WITH RX VALUE
var i = 0
var i_m = 0
var i_m_temp = 0
var GENERATED_NUMBER =0 # this variable holds the newly generated random number
var GENERATE_NEW_NUMBER = 0
var G_WAIT_COUNTER_TILL_GENERATED_NUMBER = 0
var RECEIVED_BROADCAST = 0
var ACK_TO_NEXT_ROBOT = 0
var TRACK_GENERATION_TIMES =0
var NEW_NODE_CONNECTED = 0

var I_HAVE_AN_ID = 0 # WHEN MY_ID IS GIVEN THE VALUE OF THIS VARIABLE BECOMES [2000]
var CHECK_AVAILABILITY = 0
var AVAILABLE = 2
var NOT_AVAILABLE = 3
var RECEIVED_BROADCAST_SAVED = 0

var WAIT_FOR_A_WHILE_BEFORE_CHECKING_BROKEN_CHAIN_COUNTER = 0
var CONNECTED_ROBOT[2]
var CONNECTED_TO = 0
var NODE_ONE_CONNECTED = 0
var NODE_TWO_CONNECTED = 0

var COUNTER_ = 0
#WE NEED TO KNOW IF A NODE IS DISCONNECTED OR NO LONGER IN RANGE BY SENDING BACK THE
var isROBOT_IN_NODE_STILL_AVAILABLE = 0
timer.period[0] = 300
call prox.comm.enable(1) # enable infrared communication
prox.comm.tx = BROADCAST_ID
#GENERATE RANDOM VALUE
call math.rand(i_m)
i_m = abs(i_m)
i_m_temp = i_m
#RANDOM VALUE SHOULD NOT BE GREATER THAN 2040 THE MAX VALUE PROX.COMM.RX CAN RECEICE IS 2056
if (i_m < 101) then
	i_m = 101 + i_m_temp
end
if (i_m < 2040) then
	i_m = i_m_temp/5
end
if (i_m > 2040 and i_m < 15000) then
	i_m = i_m_temp/15
end
if (i_m > 15000) then
	i_m = i_m_temp/30
end


#WE MUST DETECT IF A NODE IS NO LONGER AVAILABLE OR IN RANGE OR CONNECTED ASSUMABLY
#WE CAN ACHIEVE THIS BY SENDING A MESSSAGE TO THE ROBOT YOU'RE CONNECTED OR IN NEXT SEQUENCE 
########################  DETECT BROKEN CHAIN  ##############################
######################################################################
# BY SETTING A TIMER TO CHECK THIS SUBSEQUENTLY
timer.period[1] = 3000
#CHECKING SHOULD ONLY BE DONE WHEN A NODE IS CONNECTED
onevent timer1
	if (NODE_ONE_CONNECTED == 1 and CONNECTED_ROBOT[0] !=0 and I_HAVE_AN_ID == 2000) then
		prox.comm.tx = 0
		#NOW ASK IF THE NODE STORE IN CONNECTED_ROBOT[0] IS STILL AVAILABLE
		WAIT_FOR_A_WHILE_BEFORE_CHECKING_BROKEN_CHAIN_COUNTER++
		if (WAIT_FOR_A_WHILE_BEFORE_CHECKING_BROKEN_CHAIN_COUNTER > 20) then
			#NOW WE BROADCAST THE VALUE STORE AT CONNECTED_ROBOT[0]
			prox.comm.tx = CONNECTED_ROBOT[0] # BROADCAST VALUE STORE IN ARRAY INDEX 0
			#CHECK IF ANY RESPONSE RECEIVED MATCHES THAT VALUE STORED IN CONNECTED_ROBOT[0]
			if (prox.comm.rx == CONNECTED_ROBOT[0]) then
				CHECK_AVAILABILITY = AVAILABLE
				WAIT_FOR_A_WHILE_BEFORE_CHECKING_BROKEN_CHAIN_COUNTER = 0
				call leds.top(0,32,0)
			end
			#NO RESPONSE ? 
			if(prox.comm.rx != CONNECTED_ROBOT[0]) then
				call leds.top(32,0,0)
				WAIT_FOR_A_WHILE_BEFORE_CHECKING_BROKEN_CHAIN_COUNTER = 0
			end
		end
	end
			
	# CHECK IF THE YOU RECEIVE A REQUST WITH YOUR ID
	if(prox.comm.rx == MY_ID and I_HAVE_AN_ID == 2000)then
		COUNTER_++
		prox.comm.tx = MY_ID
		if (COUNTER_ > 80) then
			COUNTER_ = 0
			timer.period[1] = 0
			prox.comm.tx = 0
		end
	end					
										
															
																				
																									
																														
																																			
																																								
																																																	
onevent timer0
	if (GENERATE_NEW_NUMBER == 1) then
		call leds.top(0,0,32)
		G_WAIT_COUNTER_TILL_GENERATED_NUMBER++
		if (G_WAIT_COUNTER_TILL_GENERATED_NUMBER > 2) then
			i_m--
			GENERATED_NUMBER = i_m
			G_WAIT_COUNTER_TILL_GENERATED_NUMBER = 0
			
			
			#CHECK i_m DECREMENT VALUE
			if (GENERATED_NUMBER %3 == 0 and GENERATED_NUMBER % 5 == 0 and GENERATED_NUMBER >100 and GENERATED_NUMBER < 1020) then
				BROADCAST_ID = GENERATED_NUMBER
				G_WAIT_COUNTER_TILL_GENERATED_NUMBER = 0
				GENERATE_NEW_NUMBER = 0
				timer.period[0] = 0
				i_m--
				GENERATED_NUMBER = i_m
				TEMP_MY_ID = 1
				#ONCE GENERATED SEND THE NEW BROADCAST
				prox.comm.tx = BROADCAST_ID
				call leds.top(32,0,0)
			end
		end
		
		
		#ENSURE TO RESET i_m = 2041
		if (i_m < 99) then
			i_m = 1015
		end
	end


onevent prox.comm
#INITIAL SENDER SECTION USUALLY WITH ID 1 OBSVERABLE BUT NOT DETERMINED
########## ESTABLISH COMMUNICATION SEQUENCE ###
########## THIS SEGMENT TRIGGERS WHEN MY_ID = 0 AND THE RECEIVED_BROADCAST < THIS BROADCAST_ID
############ THEN THIS ROBOT TAKES PRECEDENCE BY SETTING ITS OWN ID FIRST
	#NO ID?
	#BROADCAST GENERATED ID
	if (MY_ID == 0 and NEW_NODE_CONNECTED == 0 and TEMP_MY_ID !=1) then
		call leds.top(32,0,0)#red
		#THE BROADCAST ID IS JUST AN ENTRY TO THE PROGRAM AND WILL BE RANDONMLY RE-GENERATED
		#NOW CHECK IF THE INCOMING BROADCAST ID IS SAME AS YOURS
		if (prox.comm.rx == BROADCAST_ID and (prox.comm.rx %3) == 0) then
			#THEN NEW BROADCAST HAS TO BE GENERATED
			GENERATE_NEW_NUMBER = 1
			timer.period[0] = 300
		end	
	end
#########################################################
##########################################################
##########################################################
##########################################################
# NEW BROADCAST ALREADY SENT EXPECT INCOMING BROADCAST
#CHECK IF YOUR MY_ID IS GREATER THE PROX.COMM VALUE
	if(MY_ID == 0 and BROADCAST_ID > prox.comm.rx and (prox.comm.rx %3) == 0 and TEMP_MY_ID == 1)then
		call leds.top(0,8,0)
		#SAVE THE INCOMING BROADCAST
		RECEIVED_BROADCAST = prox.comm.rx
		#ASSUME 1ST POSITION
		#ASIGN OWN ID # WE ACHIEVE THIS ONLY WHEN THE RECEIVED_BROADCAST IS LESSER THAN THE BROADCAST_ID
		MY_ID = 1
		I_HAVE_AN_ID = 2000
		#COMPUTE THE NEXT ID
		ACK_TO_NEXT_ROBOT = MY_ID + RECEIVED_BROADCAST
		prox.comm.tx = ACK_TO_NEXT_ROBOT
	end		
	
	
		#GET A CONFIMATION FROM THE NEXT NODE
		#EXPECTED VALUE IS ACK_TO_NEXT_ROBOT + 1
	if (prox.comm.rx == ACK_TO_NEXT_ROBOT + 1 and MY_ID > 0) then
		#HERE WE CAN ASSUME THAT A ROBOT IS IN RANGE AND CONNECTED TO THIS NODE
		#SAVE THE ID
		CONNECTED_TO =  (ACK_TO_NEXT_ROBOT  - RECEIVED_BROADCAST)+ 1
		NEW_NODE_CONNECTED = 1
		call leds.top(0,32,0)
		timer.period[0] = 0
		prox.comm.tx = 0 #SEND NOTHING FOR NOW
	end	
		
#RECEIVER SECTION
########## THIS SEGMENT TRIGGERS WHEN MY_ID = 0 AND THE BROADCAST_ID < RECEIVED_BROADCAST
############# WAIT FOR RESPONSE FROM THE OTHER ROBOT THEN SET THE REPLY TO OWN MY_ID
	if (MY_ID == 0 and NEW_NODE_CONNECTED == 0 and BROADCAST_ID < prox.comm.rx and (prox.comm.rx %3) == 0) then
				call leds.top(8,0,0)		
				#SAVE THE INCOMING BROADCAST
				RECEIVED_BROADCAST = prox.comm.rx
				RECEIVED_BROADCAST_SAVED = 1
	end
	#GET AN ACK FROM THE ROBOT WHOSE BROADCAST_ID IS GREATER YOURS
	if (prox.comm.rx != RECEIVED_BROADCAST and RECEIVED_BROADCAST_SAVED == 1) then
				ACK_RCVD = prox.comm.rx
	end
	#NOW CONFIRM THE ACK RCVD AND PASS VALUE TO THE SENDER
	if (abs(ACK_RCVD - BROADCAST_ID) == 1 and RECEIVED_BROADCAST_SAVED == 1) then
				MY_ID = (ACK_RCVD - BROADCAST_ID) + 1
				#SAVE THE IN YOUR PREV SEQUENCE
				CONNECTED_ROBOT[0] = (ACK_RCVD - BROADCAST_ID)
				NODE_ONE_CONNECTED = 1
				I_HAVE_AN_ID = 2000
				call leds.top(0,32,0)
				prox.comm.tx = ACK_RCVD +1
	end
##################################################################################	
#WE MUST DETECT IF A NODE IS NO LONGER AVAILABLE OR IN RANGE OR CONNECTED ASSUMABLY
#WE CAN ACHIEVE THIS BY SENDING A MESSSAGE TO THE ROBOT YOU'RE CONNECTED OR IN NEXT SEQUENCE 




####################################################################
#REPOND TO TO ANY BROADCAST REQUESTING YOUR ID BY PASSING THE ID BACK AS A RESPONSE
	if (prox.comm.rx == MY_ID and I_HAVE_AN_ID == 2000) then
		#SEND WITHIN IN TIME PERIOD
		timer.period[1] = 300
	end
######################################################	
	
	
	