<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--node Thymio-II Wireless-->
<node nodeId="{d2296ad0-cbf6-4c78-8465-79e195d4de4b}" name="Thymio-II Wireless"><![CDATA[# this code seems to work better than others
#Collision Avoidance
#Robot is intended to avoid obstacles and give feedback obstacle in range of sensor readings
var staticSensorThreshold = 3200
var sensorFrontMax = 0 
var sensorBackMax = 0

var reverseProtocal = 0

var kickStart = 0

var reverseFromLeft = 0
var reverseFromRight = 0

var initiateReverse = 0
var countLeftSteps = 0
var countRightSteps = 0
var countFrontSteps = 0
var sensorSumFront = 0
var sensorSumBack = 0 

var shouldMove = 0 # holds the value moving 1 and not moving 0
var i =0  #variable set default to 1
var sensorFrontArray[5] #array to hold sensor array at the front
var sensorBackArray[2] # array to hold sensor array at the back
var overrideRemote = 0
var direction = 0 # 0: hasn-t just turned; 1: just turned left; 2: just turned right; 3: just moved back
#initial movement disabled
motor.left.target = 0
motor.right.target = 0

 #timer default set to 0 
  timer.period[0]= 200
  timer.period[1]= 0
 
 #set led default to off
 call leds.bottom.right(0,0,0)
 call leds.bottom.left(0,0,0)
 call leds.top(32,32,0)

#------------------------------------------------------Remote Control Signal to Robot------------------------------------------------------
  #here we init robot movement forwared with remote control
onevent rc5
 if (rc5.command == 53) then
 	shouldMove = 1
 	call leds.top(31,31,12) #change color code to specified	
 
 #halt robot movement on remote signal 13 or 87
elseif (rc5.command == 87) then
 	call leds.top(31,0,0) # change color to red on remote signal 13
 	shouldMove = 0 #set moving to false
 	motor.left.target = 0
 	motor.right.target = 0
end
 	
#-----------------------------------------------------------------------------Collision Avoidance---------------------------------------------------------	
 #obstacle avoidance
onevent prox	
	# front sensor array
	sensorFrontArray[0] = prox.horizontal[0]
	sensorFrontArray[1] = prox.horizontal[1]
	sensorFrontArray[2] = prox.horizontal[2]
	sensorFrontArray[3] = prox.horizontal[3]
	sensorFrontArray[4] = prox.horizontal[4]
	# back sensor array
	sensorBackArray[0] =  prox.horizontal[5]
	sensorBackArray[1] =  prox.horizontal[6]
	#max of front sensor array
	sensorFrontMax = 0
	#max of back sensor array
	sensorBackMax = 0
	#sum of front sensor array
	sensorSumFront = 0
	#sum of back sensor array
	sensorSumBack = 0
#----------------------------------------------Loop to track sensor readings ----------------------------------	
	# loop to find max front sensors
	for i in 0:4 do
		if (sensorFrontArray[i] > sensorFrontMax) then
			sensorFrontMax = sensorFrontArray[i]
		end
	end
	
	# loop to find max back sensors
	for i in 0:1 do
		if (sensorBackArray[i] > sensorBackMax) then
			sensorBackMax = sensorBackArray[i]
		end
	end
	
	# sum of front sensors
	for i in 0:4 do
		sensorSumFront = sensorSumFront+ sensorFrontArray[i]
	end
	
	# sum of back sensors
	for i in 0:1 do
		sensorSumBack = sensorSumBack+ sensorBackArray[i]
	end
#------------------------------------------Loop declararations Ends here--------------------------------------------	

if (shouldMove == 1) then
	call leds.top(0,31,0)
	if (sensorFrontMax < 900) then # only moves forward when no sensor readings higher than 0
			call leds.top(0,31,0)
			motor.left.target = 2000
			motor.right.target = 2000
			reverseFromRight = 0
			reverseFromLeft = 0
	 	elseif (prox.horizontal[1] > 900 or prox.horizontal[0] > 900) then
	 		#turn left
	 		call leds.top(31,0,0)
	 		#motor.left.target = 100
	 		motor.right.target = -200
	 		reverseFromLeft = 1
	 		countLeftSteps++
	 		
		elseif (prox.horizontal[3] > 900 or prox.horizontal[4]>900) then
	 		#turn right
	 		call leds.top(31,0,0)
	 		#motor.right.target = 100
			motor.left.target = -200
			#reverseFromRight = 1
			countRightSteps++	
			
		#middle sensor at 2
			elseif (sensorFrontMax == prox.horizontal[2]) then
	 		#turn right
	 		call leds.top(31,0,0)
	 		#countFrontSteps++
	 		#motor.left.target = 0
			#motor.left.target = -50
			#robot stuck in front?
			elseif (prox.horizontal[2] == sensorFrontMax and prox.horizontal[2] == sensorSumFront) then
				countFrontSteps++
				
			#check rear sensor
			elseif (sensorSumBack > 7000) then
			motor.right.target = 500
			motor.left.target =	 500
			
			
	end	

end


if (countRightSteps > 2) then
	motor.right.target = 900
	motor.left.target = 900
	countRightSteps = 0
	
elseif (countLeftSteps  > 2) then
	motor.right.target = 900
	motor.left.target = 900
	countLeftSteps = 0
	
elseif (countFrontSteps > 1) then
	motor.right.target = -200
	motor.left.target = -200
	countFrontSteps = 0
	
end


if (sensorFrontMax > 3000) then
	initiateReverse++
end

if(initiateReverse >2) then
	call leds.top(0,0,32)
	motor.right.target = -900
	motor.left.target = -900
	initiateReverse=0
	reverseProtocal++
end

if (reverseProtocal > 3) then
	motor.right.target = 900
	motor.left.target = 900
	reverseProtocal=0
end]]></node>


<!--node -->
<node name=""><![CDATA[#Collision Avoidance
#Robot is intended to avoid obstacles and give feedback obstacle in range of sensor readings
var sensorMax = 0 
var shouldMove = 0 # holds the value moving 1 and not moving 0
var i =0  #variable set default to 1
var sensorArray[7] 
var overrideRemote = 0
#initial movement disabled
motor.left.target = 0
motor.right.target = 0

 #timer default set to 0 
  timer.period[0]=0
  timer.period[1]= 0
 
 #set led default to off
 call leds.bottom.right(0,0,0)
 call leds.bottom.left(0,0,0)
 call leds.top(0,0,0)

#------------------------------------------------------Remote Control Signal to Robot------------------------------------------------------
  #here we init robot movement forwared with remote control
onevent rc5
 if (rc5.command == 53) then
 	shouldMove = 1
 	call leds.top(31,31,12) #change color code to specified	
 
 #halt robot movement on remote signal 13 or 87
elseif (rc5.command == 87) then
 	call leds.top(31,0,0) # change color to red on remote signal 13
 	shouldMove = 0 #set moving to false
 	motor.left.target = 0
 	motor.right.target = 0
end
 	
#-----------------------------------------------------------------------------Collision Avoidance---------------------------------------------------------	
 #obstacle avoidance
onevent prox	
	sensorArray = prox.horizontal
	sensorMax = 0
	
	for i in 0:6 do
		if (sensorArray[i] > sensorMax) then
			sensorMax = sensorArray[i]
		end
	end
if (shouldMove == 1) then
	
	   #obstacle at sensor 0 left sensor
	if (sensorArray[0] == sensorMax) then
			call leds.bottom.left(31,14,2)
			motor.left.target = -200 #turn left
			
		#obstacle at sensor 1 left-middle sensor
	elseif (sensorArray[1] == sensorMax) then
			call leds.bottom.left(31,14,2)
			motor.left.target = -200 #turn left
			
		#obstacle at sensor 2 middle sensor
	elseif (sensorArray[2] == sensorMax) then
			call leds.bottom.left(31,14,2)
			motor.left.target = -200 #turn left
				
				#obstacle at sensor 3 -  right-middle sensor
	elseif (sensorArray[3] == sensorMax) then
			call leds.bottom.left(31,14,2)
			motor.right.target = -200 #turn right	
				
				#obstacle at sensor 4 -  right sensor
	elseif (sensorArray[4] == sensorMax) then
			call leds.bottom.left(31,14,2)
			motor.right.target = -200 #turn right
			
	elseif (shouldMove == 1) then
			call leds.bottom.left(0,31,0)
			motor.right.target = 500
			motor.right.target = 500
end
 		
	
	
end]]></node>


</network>
